#!/usr/bin/env python
from __future__ import print_function
import re
try:
    import subprocess32 as sp
except ImportError:
    import subprocess as sp
import argparse
import os 
import atexit
import signal
import glob
import time
import sys

def kill_sp(pids):
    """ensure processes killed if this script is killed"""
    for pid in pids:
        if pid is None:
            pass
        else:
            try:
                os.killpg(pid, signal.SIGTERM)
            except OSError:
                pass

class cd:
    """Context manager for changing the current working directory"""
    def __init__(self, newPath):
        self.newPath = os.path.expanduser(newPath)

    def __enter__(self):
        self.savedPath = os.getcwd()
        os.chdir(self.newPath)

    def __exit__(self, etype, value, traceback):
        os.chdir(self.savedPath)


def which(program):
    """Get exectuables which exist on path"""
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return program


def get_subprocess_error(e):
    print("subprocess ERROR")
    import json
    error = json.loads(e[7:])
    print(error['code'], error['message'])


def runcmd(cmd):

    try:
        run = sp.Popen(cmd, stdout=sp.PIPE, stderr=None, shell=True)
    except sp.CalledProcessError as e:
        if e.output.startswith('error: {'):
            get_subprocess_error(e.output)
        raise

    return run

def execute(cmd, blocking=True):
    """
    Outputs results as they are generated, example usage:

    from __future__ import print_function

    for path in execute(["locate", "a"]):
        print(path, end="")

    """
    popen = sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.STDOUT, 
                     shell=True, universal_newlines=True)
    for stdout_line in iter(popen.stdout.readline, ""):
        yield stdout_line 
    popen.stdout.close()
    if blocking:
        return_code = popen.wait()

    if return_code:
        raise sp.CalledProcessError(return_code, cmd)



def check_for_error(proc):
    """
        If an Error (e.g. NameError) is raised by a Python
        script after cpl has opened a port and merged two processes
        do not trigger the subprocess error code (as the coupled code
        in this case does not call MPI Abort due to a Python error)
        So we need to catch this manually
    """
    for line in iter(proc.stderr.readline, b''):
        if "NameError" in line:
            raise NameError(line)
            sys.exit(1)
        elif "Error" in line:
            print(line)
            sys.exit(1)
        else:
            print(line)


# This script runs two codes seperatly in thier own directories
# and ensure the coupled run works correctly. To do this:
# 1) The version of CPL library, MPI and compiler should be the same
#    for both codes, this is checked before running.
# 2) The two codes can be started in MPMD mode or individually.
#    Starting indivdually is more general (and potentially more efficients
#    as intra-communications are 3D while coupled only along a 2D plane.)
#    The MPI instances are connected by opening a port, writing details to 
#    file and reading with the other code. This script ensures the 
#    port file, written at location of exec 1 is available to exec 2.
# 3) Running with PBS or other service is simplified by a single cplexec

def get_libraries(filename=None):
    """
     Get List of Librairies in Dictionary
    """
    lddOut = sp.check_output(['ldd', filename])
    libraries = {}
    for line in lddOut.splitlines():
        match = re.match(r'\t(.*) => (.*) \(0x', line)
        if match:
            libraries[match.group(1)] = match.group(2)

    return libraries


#Keyword arguments
description = """
Run coupled case. Note, only script.py needed for python.
First argument after keywords is the exectuable and all other arguments are inputs.
If using some form of debugger or testing (gdb, valgrind, etc) then you need to specify
the executable seperatly.
"""
parser = argparse.ArgumentParser(description=description)

parser.add_argument('-m', '--md', nargs=2,
                    help='Specify two arguments: No. of MD processors and MD executable with all space seperated arguments in quotes', 
                    required=True)

parser.add_argument('-c', '--cfd', nargs=2,
                    help='Specify two arguments: No. of CFD processors and CFD executable with all space seperated arguments in quotes',
                    required=True)

parser.add_argument('-v', '--verbose', help='Specify verbosity', required=False, action="store_true")


args = vars(parser.parse_args())

if args["verbose"]:
    print("\n")
    print("============")
    print("Verbose Mode")
    print("============\n")
    print("\n")


nprocs_CFD = args['cfd'][0]
arg = args['cfd'][1].split(" ")
exec_CFD = arg[0]
if len(arg) > 1:
    args_CFD = arg[1:]
else:
    args_CFD = []
nprocs_MD = args['md'][0]
arg = args['md'][1].split(" ")
exec_MD = arg[0]
if len(arg) > 1:
    args_MD = arg[1:]
else:
    args_MD = []

#Create dict for run info
CFDDict = {"exec":exec_CFD, "nproces":nprocs_CFD, "args":args_CFD}
MDDict = {"exec":exec_MD, "nproces":nprocs_MD, "args":args_MD}
Dicts = {"MD":MDDict, "CFD":CFDDict}

for k in Dicts:
    #Check executables exist
    d = Dicts[k]
    e = d["exec"]

    #If just executable specified (e.g. on path) then get full path
    if e.find("/") == -1:
        e = which(e)

    if not os.path.isfile(e):
        msg = "Executable " + e + " not found. "
        raise IOError(msg)

    #Check if python script of executable
    if ".py" in e:
        d["ispython"] = True
    else:
        d["ispython"] = False

    if d["ispython"]:
        try:
            from cplpy import CPL
            d["cpl_path"] = CPL._lib_path + "/" + CPL._libname +".so"
            if args["verbose"]:
                print("CPL path ", d["cpl_path"])
        except ImportError:
            print("CPL library not importable in Python, " +
                  "have you called source SOURCEME.sh in cpl-library")
            raise

        try:
            import mpi4py
            mpibinpath = mpi4py.get_config()["mpicc"]
            mpilibpath = "/" + mpibinpath.replace("/bin/mpicc", "/lib/libmpi.so")
            #libs = mpilibpath + "libmpi.so" #glob.glob(mpilibpath + "*mpi*")
            if not os.path.isfile(mpilibpath):
                msg = "libmpi.so not found under " + mpilibpath
                raise IOError(msg)
            else:
                d["libs"] = {"libmpi.so":mpilibpath}
        except ImportError:
            print("mpi4py import error, please check this is installed correctly")


    else:
        d["libs"] = get_libraries(e)
        for lib, lpath in d["libs"].items():
            if "libcpl.so" in lib.lower():
                d["cpl_path"] = os.path.normpath(lpath)

    try:
        d["cpl_path"]
    except KeyError:
        print("CPL library path not found, have you compiled you " +
              "executable correctly to include libcpl.so?")

#Compare versions of CPL
if Dicts["MD"]["cpl_path"] != Dicts["CFD"]["cpl_path"]:
    print("Warning -- different CPL linked into executables")
else:
    cpllib = get_libraries(Dicts["MD"]["cpl_path"])


#Check version of cpl library is linked in correctly 
# and is the same version for executables
#CFDlib = get_libraries(CFD)
#for lib, lpath in CFDlib.items():
#    if "libcpl.so" in lib.lower():
#        print("CFD CPL", lib, lpath)
#        CFD_cpl = os.path.normpath(lpath)

#MDlib  = get_libraries(MD)
#for lib, lpath in MDlib.items():
#    if "libcpl.so" in lib.lower():
#        print("MD CPL", lib, lpath)
#        MD_cpl = os.path.normpath(lpath)

##Check cpl library is actually linked in
#if MD_cpl != CFD_cpl:
#    print("Warning -- different CPL linked into executables")
#else:
#    cpllib = get_libraries(CFD_cpl)

#Check for MPI libraries for both cpl and executables are the same
for lib, lpath in cpllib.items():
    if "mpi" in lib:
        if args["verbose"]:
            print("CPL MPI libs", lib, lpath)
        CPL_mpi = os.path.realpath(lpath)

for lib, lpath in Dicts["CFD"]["libs"].items():
    if "mpi" in lib:
        if args["verbose"]:
            print("CFD MPI libs", lib, lpath)
        #CFD_mpi = os.path.normpath(lpath)
        Dicts["CFD"]["MPI"] = os.path.realpath(lpath)


for lib, lpath in Dicts["MD"]["libs"].items():
    if "mpi" in lib:
        if args["verbose"]:
            print("MD MPI libs", lib, lpath)
        #MD_mpi = os.path.normpath(lpath)
        Dicts["MD"]["MPI"] = os.path.realpath(lpath)

if (Dicts["MD"]["MPI"] != Dicts["CFD"]["MPI"]) or (CPL_mpi != Dicts["CFD"]["MPI"]):
    print("Warning -- different MPI linked into executables")
    mpilibs = get_libraries(CPL_mpi)
else:
    mpilibs = get_libraries(CPL_mpi)

# Check fortran and c++ compilers are consistent 
# for mpi, cpl and executables
libs = [cpllib, mpilibs, Dicts["MD"]["libs"], Dicts["CFD"]["libs"]]
compilers = ["gcc", "gfortran", "stdc++"]
checkDict = {}
for lib in libs:
    for mlib, mlpath in lib.items():
        for c in compilers:
            if c in mlib:
                if c in checkDict:
                    if (checkDict[c] != mlpath):
                        print("Warning -- different version of ", c ," linked into executables")
                else:
                    checkDict[c] = mlpath

if args["verbose"]:
    print("Compilers all the same : ", checkDict)

# We will also need to check for and copy port file if needed here because
# executables are in different folders...

#Python scripts
for k in Dicts:
    d = Dicts[k]
    if d["ispython"]:
        d["exec"] = "python " + d["exec"]


#Remove previous port file
sp.Popen("rm -f ./port", shell=True)

cmdstr_MD = ["mpiexec", "-n", str(nprocs_MD), MDDict["exec"]] + MDDict["args"]
cmdstr_CFD = ["mpiexec", "-n", str(nprocs_CFD), CFDDict["exec"]] + CFDDict["args"]

if args["verbose"]:
    print("MD Commands to run ", cmdstr_MD)
    print("CFD Commands to run ", cmdstr_CFD)

# Create a processor group using preexec_fn=os.setsid
# so they can be killed as one.
p_CFD = sp.Popen(' '.join(cmdstr_CFD), stderr=sp.PIPE, 
                 shell=True, preexec_fn=os.setsid, bufsize=1)
p_MD = sp.Popen(' '.join(cmdstr_MD), stderr=sp.PIPE, 
                shell=True, preexec_fn=os.setsid, bufsize=1)

#Register killer of subprocesses if python script killed 
atexit.register(kill_sp, [os.getpgid(p_MD.pid), os.getpgid(p_CFD.pid)])

#Endless loop polling to see if codes have failed and checking
#output error streams for any hint of error
while True:
    time.sleep(2.0)
    if args["verbose"]:
        print("POLL CFD = ", p_CFD.poll())
        print("POLL MD = ", p_MD.poll())

    if p_CFD.poll():
        raise sp.CalledProcessError(p_CFD.poll(), ' '.join(cmdstr_CFD))
        sys.exit(1)
    else:
        check_for_error(p_CFD)

    if p_MD.poll():
        raise sp.CalledProcessError(p_MD.poll(), ' '.join(cmdstr_MD))
        sys.exit(1)
    else:
        check_for_error(p_MD)


    if p_MD.poll() == 0 and p_CFD.poll() == 0:
        if args["verbose"]:
            print("cplexec Finished successfully")
        break

#Return successful exit code
sys.exit(0)

#CFD_gen = execute(' '.join(cmdstr_CFD))
#MD_gen = execute(' '.join(cmdstr_MD))
#c = CFD_gen.next()
#m = MD_gen.next()
#for path in range(1000):
#    cn = CFD_gen.next()
#    if (c != cn):
#        print(cn)
#        c = cn

#    mn = CFD_gen.next()
#    if (m != mn):
#        print(mn)


#rc_CFD = p_CFD.wait()
#if rc_CFD:
#    raise sp.CalledProcessError(rc_CFD, ' '.join(cmdstr_CFD))

#rc_MD = p_MD.wait()
#if rc_MD:
#    raise sp.CalledProcessError(rc_MD, ' '.join(cmdstr_MD))


