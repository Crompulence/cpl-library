/*

    ________/\\\\\\\\\__/\\\\\\\\\\\\\____/\\\_____________
     _____/\\\////////__\/\\\/////////\\\_\/\\\_____________
      ___/\\\/___________\/\\\_______\/\\\_\/\\\_____________
       __/\\\_____________\/\\\\\\\\\\\\\/__\/\\\_____________
        _\/\\\_____________\/\\\/////////____\/\\\_____________
         _\//\\\____________\/\\\_____________\/\\\_____________
          __\///\\\__________\/\\\_____________\/\\\_____________
           ____\////\\\\\\\\\_\/\\\_____________\/\\\\\\\\\\\\\\\_
            _______\/////////__\///______________\///////////////__


                         C P L  -  L I B R A R Y

           Copyright (C) 2012-2015 Edward Smith & David Trevelyan

License

    This file is part of CPL-Library.

    CPL-Library is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CPL-Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CPL-Library.  If not, see <http://www.gnu.org/licenses/>.


Description

    Utility class that provides Fortran-like N-dimensional arrays (up to
    4D) to C++ programs that are to interface with CPL-Library. The ordering
    of the internal data is stored in Fortran column-major order, so objects
    of this class may be communicated directly with CPL-Library without any
    need for re-ordering.

    The () operator is overloaded to provide a simple interface that is
    identical to Fortran-array element access (except that indices count
    from 0, rather than 1).

        constexpr arrayDims = 3;
        int arrayShape[arrayDims] = {3, 5, 8};
        CPL::ndArray<int> A(arrayDims, arrayShape)
        A(1, 0, 7) = 314; // Sets element 1,0,7 to 314

Author(s)
    
    David Trevelyan

*/

#ifndef CPL_NDARRAY_H_INCLUDED
#define CPL_NDARRAY_H_INCLUDED

#include<exception>
#include<string>
#include<sstream>
#include<vector>
#include<iostream>
#include <memory>

//Make unique function as we are using c++ 11
//template<typename T, typename... Args>
//std::unique_ptr<T> make_unique(Args&&... args)
//{
//    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
//}

#include <cstddef>
#include <type_traits>
#include <utility>

namespace std {
    template<class T> struct _Unique_if {
        typedef unique_ptr<T> _Single_object;
    };

    template<class T> struct _Unique_if<T[]> {
        typedef unique_ptr<T[]> _Unknown_bound;
    };

    template<class T, size_t N> struct _Unique_if<T[N]> {
        typedef void _Known_bound;
    };

    template<class T, class... Args>
        typename _Unique_if<T>::_Single_object
        make_unique(Args&&... args) {
            return unique_ptr<T>(new T(std::forward<Args>(args)...));
        }

    template<class T>
        typename _Unique_if<T>::_Unknown_bound
        make_unique(size_t n) {
            typedef typename remove_extent<T>::type U;
            return unique_ptr<T>(new U[n]());
        }

    template<class T, class... Args>
        typename _Unique_if<T>::_Known_bound
        make_unique(Args&&...) = delete;
}

namespace CPL
{

    // N-dimensional array class where the data is guaranteed to be contiguous
    template<class T>
    class ndArray
    {

    public:

        // Constructor with no arguments, don't allocate
        ndArray();

        // Constructor taking in number of dimensions, shape and optional order
        ndArray(const int nd, const int shape[], const char ordering=defaultOrder);
    
        // Construct from pointer to existing data, number of dimensions and
        // shape, with optional ordering
        ndArray(const T* existingData, const int nd, 
                const int shape[], const char ordering=defaultOrder);

        // Destructor automatically generated by compiler
        //~ndArray();

        // Deallocate data, resizes to 0
        void clear();

//        //Need value type, begin, end and iterator here
//        typedef T value_type;
//        std::begin();
//        std::end();
//        std::const_iterator();

//        iterator begin() { return 0; }
//        iterator end() { return this.size(); }
//        iterator iter() {
//            for( iter it = this.begin(); it != this.end(); ++i ) {
//                // use *i ...
//            }
//        }

        // Number of elements of the ndArray along the dim axis
        int shape (const int dim);

        // Pointer to the front of the shapeVector array
        int* shapeData();

        // Pointer to front of internal array
        T* data();

        // Number of elements
        int size();

        // Min/max/sum functions
        double min();
        double max();
        double sum();
        std::vector<T> sum(const int dim);


        // Allocation after empty construction
        void resize (const int nd, const int shape[]);

        // Element access - support up to 4 dimensions
        // 1D
        T operator ()  (const int i0) const;
        T& operator () (const int i0);

        // 2D
        T operator ()  (const int i0, const int i1) const;
        T& operator () (const int i0, const int i1);

        // 3D
        T operator ()  (const int i0, const int i1, const int i2) const;
        T& operator () (const int i0, const int i1, const int i2);

        // 4D
        T operator ()  (const int i0, const int i1, const int i2, const int i3) const;
        T& operator () (const int i0, const int i1, const int i2, const int i3);

        // Assignment operator from single value
        ndArray& operator= (const T &rhs);

        // Arithmetic operators from single value
        ndArray& operator+= (const T &rhs);
        ndArray& operator-= (const T &rhs);
        ndArray& operator*= (const T &rhs);
        ndArray operator+ (const T &rhs);
        ndArray operator- (const T &rhs);
        ndArray operator* (const T &rhs);

        // Check dimensionality is a certain value
        bool checkDimsEquals (const int dims) const;

        // Return string information about the object
        std::string info();

        // Return string all the elements of the internal data
        std::string infoData();

        // Print the array prettily
        std::string infoArray();

    private:

        // Internal 1D data array
        std::vector<T> ndArrayData;
        
        // Number of dimensions
        int nDims;

        // C or Fortran ordering
        static const char defaultOrder = 'F';
        char order;
        
        // Shape (size in each dimension)
        std::vector<int> shapeVector;

        // Number of elements
        int nElements;

        // Exceptions
        class wrongShape: public std::exception
        {
            const char* what() const throw()
            {
                return "Wrong number of arguments to ndArray.operator()";
            }
        } shapeEx;
        
        class invalidOrder: public std::exception
        {
            const char* what() const throw()
            {
                return "CPL::ndArray ordering may only be 'F' or 'C'";
            }
        } orderEx;

        // Convert nd indices to 1D index position
        int flatIndex(int i0) const;
        int flatIndex(int i0, int i1) const;
        int flatIndex(int i0, int i1, int i2) const;
        int flatIndex(int i0, int i1, int i2, int i3) const;

    };

}

#endif // CPL_NDARRAY_H_INCLUDED
